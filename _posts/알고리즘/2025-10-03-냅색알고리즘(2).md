---
title: "[알고리즘][Python] 냅색 알고리즘(2)"
layout: single
categories: DP
author_profile: true
sidebar_main: true
tag: [Algorhythm, Python, DP]
published: true
---

알고리즘
{: .notice--success}


## 위상정렬

**선택하지 않는 것도 선택이다.**<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;***- 장 폴 사르트르***
{: .notice--warning}

저번에 작성한 냅색 알고리즘에 대한 풀이는 **같은 자원을 중복해서 여러 번 선택**할 수 있다는 가정이였다.   
하지만 **"단 한 번"**만 선택할 수 있는 자원은 어떨까?   

여러개의 자원들이 존재할 때 **각 자원들을 최대 1번씩만 선택할 수 있는 상태에서 최선의 선택**을 알아내야할 때도 **냅색 알고리즘**을 사용할 수 있다.


## 해결방식

> **"발상의 전환"**

기본적으로 냅색 알고리즘을 구성하는 방식은 같다.   
하지만 단 하나 다른점은 냅색 리스트를 **역순**으로 돌면서 계산을 한다는 점이다.   

냅색 리스트를 **[0]번 인덱스부터 순회하면 [i - item_size] + item_cost를 하면 중복이 될 수 밖에 없지만,**   
[max_length]번 인덱스부터 역순으로 순회하면 [i - item_size] + item_cost는 **중복이 될 수없다.**   

왜냐하면 i = 20이고 item_size = 5인 경우, [20]번에 [20 - 5] + item_cost이 된다.   
애초에 **[20, 19, 18, ...]**처럼 **역순**으로 순회하면 **[15, 14, 13, ...]에 + cost를 하는 것**이기 때문에 **한 번도 방문하지 않은 인덱스를 참조해서 중복이 일어나지 않는다.**

![image](/assets/images/알고리즘/냅색(2)_2.png){: width="50%", height="50%"}


<br/>


## 코드구현

```python
class Node:
    def __init__(self, node_size, node_cost):
        self.node_size = int(node_size)
        self.node_cost = int(node_cost)


print("가방의 크기를 입력하세요. : ", end="")
knap_cnt = int(input()) # 가방의 크기
knapsack = [ 0 for _ in range(knap_cnt + 1)]

print("코스트를 입력할 갯수를 입력하세요 : ", end="")
node_cnt = int(input()) # 코스트 갯수

node_list = []
print("크기, 코스트 입력")
for i in range(node_cnt):
    weight_cost = input().split()
    node_list.append(Node(weight_cost[0], weight_cost[1]))
        

# 중복 선택이 가능한 냅색이랑 가장 차이점은 knapsack 배열을 역순으로 돌면서 확인한다는 것이다.
for i in range(node_cnt): # 입력된 코스트 갯수 전부 돌기
    node_size = node_list[i].node_size
    node_cost = node_list[i].node_cost
    for j in range(knap_cnt, node_size - 1, -1): # knap_cnt ~ node_size 까지 역순으로 순회한다.
        knapsack[j] = max(knapsack[j], knapsack[j - node_size] + node_cost) # 현재 knapsack[j]과 knapsack[j - node_size] + node_cost를 비교해서  더 큰 것을 저장
    

print(f"최대 가치 : {knapsack[knap_cnt]}")  
```

<br/>

## 결과
![image](/assets/images/알고리즘/냅색(2).png)

> **for j in range(knap_cnt, node_size - 1, -1)**

**한 번만 선택 가능한 냅색 알고리즘의 가장 핵심 코드이다.**   


![image](/assets/images/알고리즘/냅색(2)_3.png){: width="50%", height="50%"}
![image](/assets/images/알고리즘/냅색(2)_4.png){: width="50%", height="50%"}

- **기본적으로 흐름 자체는 기본 냅색 알고리즘과 동일하다.**
    - 냅색 알고리즘(1) 참고
- **knap_cnt ~ node_size까지 역순으로 도는 것이 중요하다.**
    - 역순으로 돌기 때문에 **한 번도 방문하지 않은 인덱스의 값**에 코스트를 더하는 것이 가능하기 때문이다.


> 역순으로 순회하면 현재 인덱스 j를 계산할 때, **참조하는 j - node_size는 항상 아직 방문하지 않은 인덱스이므로**   
**이전 현재 아이템을 사용하지 않은 상태**의 라운드 값을 참조하게 되어 **아이템 중복 사용을 방지할 수 있다.**
{: .notice--success}


<br/>

**크기가 한정적인 공간**에 여러가지 아이템을 저장할 수 있을 때 **크기와 가치가 있는 경우 최선의 방식. 하지만 단 한 번만 선택이 가능한 경우**에 유용한 알고리즘이다.


