---
title: "[알고리즘][Python] 냅색 알고리즘"
layout: single
categories: DP
author_profile: true
sidebar_main: true
tag: [Algorhythm, Python, DP]
published: true
---

알고리즘
{: .notice--success}


## 위상정렬

**공짜 점심은 없다.**<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;***- 밀턴 프리드먼***
{: .notice--warning}


냅색(가방) 알고리즘은 **제한된 자원 안에서 최대의 가치를 선택하는 알고리즘이다.**
다이나믹 프로그래밍에 속하며 여기서 제한된 가치란 **가방의 무게, 한정된 비용(코스트)** 등을 말한다. 

즉, **제한된 자원에서 최선의 선택**이 무엇인지 알 수 있는 알고리즘이다.


## 해결방식

> **"현재 가방의 크기에서 현재 고를 수 있는 아이템의 코스트를 더한다면, 더하지 않았을 때와 더했을 때 무엇이 더 많이 담을 수 있는가?"**

냅색 알고리즘은 다이나믹 프로그래밍의 한 종류이다.
그래서 현재의 가장 최선의 선택을 알기 위해서는 전단계의 최선의 선택을 이용하여 구해내야한다.

### 순서
1. 냅색(가방)의 크기를 나타내는 리스트를 선언한다.
2. 클래스나 구조체에 크기와 크기에 따른 코스트를 저장한다.
3. 저장한 클래스를 리스트로 저장한다.
4. 리스트로 저장한 아이템을 순회하면서 최선의 선택을 계산하여 업데이트 해준다.
- **냅색 리스트[현재 크기] = max(냅색 리스트[현재 크기], 냅색 리스트[현재 크기 - 아이템 사이즈] + 아이템 코스트)**
5. 전부다 순회하면 냅색 리스트의 가장 마지막에는 **"이 가방에서 선택 가능한 가장 최선의 선택"**이 저장된다.



<br/>


## 코드구현

```python
class Node:
    def __init__(self, node_size, node_cost):
        self.node_size = int(node_size)
        self.node_cost = int(node_cost)


print("가방의 크기를 입력하세요. : ", end="")
knap_cnt = int(input()) # 가방의 크기
knapsack = [ 0 for _ in range(knap_cnt + 1)]

print("코스트를 입력할 갯수를 입력하세요 : ", end="")
node_cnt = int(input()) # 코스트 갯수

node_list = []
print("크기, 코스트 입력")
for i in range(node_cnt):
    weight_cost = input().split()
    node_list.append(Node(weight_cost[0], weight_cost[1]))


for i in range(node_cnt): # 입력된 코스트 갯수 전부 돌기
    node_size = node_list[i].node_size
    node_cost = node_list[i].node_cost
    for j in range(node_size, knap_cnt + 1): # node_size 부터 검사한다. 
        knapsack[j] = max(knapsack[j], knapsack[j - node_size] + node_cost) # 현재 knapsack[j]과 knapsack[j - node_size] + node_cost를 비교해서  더 큰 것을 저장
    

print(f"최대 가치 : {knapsack[knap_cnt]}")  

```

<br/>

## 결과
![image](/assets/images/알고리즘/냅색 결과.png)

> **knapsack[j] = max(knapsack[j], knapsack[j - node_size] + node_cost)**

**냅색 알고리즘의 가장 핵심 코드이다.**   

현재 선택할 수 있는 최선의 선택을 **전 단계의 최선의 선택을 이용하여 구하고**, 더 많이 선택할 수 있는 것을 저장한다.   
문제를 작은 단위로 쪼개 점진적으로 해결해나가는 다이나믹 프로그래밍의 특성을 돋보이는 알고리즘이다.

<br/>

**크기가 한정적인 공간**에 여러가지 아이템을 저장할 수 있을 때 **크기와 가치가 있는 경우 최선의 방식**이 무엇인지 알아내야할 때 사용하면 좋을 것 같다.


