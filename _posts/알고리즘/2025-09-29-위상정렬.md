---
title: "[알고리즘][Python] 위상정렬"
layout: single
categories: Graph
author_profile: true
sidebar_main: true
tag: [Algorhythm, Python, Graph]
published: true
---

알고리즘
{: .notice--success}


## 위상정렬

**모든 것에는 순서가 있다.**<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;***- 세네카***
{: .notice--warning}


위상 정렬은 **<u>선후관계가 있는 작업</u>**들을 올바른 순서대로 나열하는 알고리즘이다.   
일의 특정 순서가 있는 경우 **<u>반드시 지켜져야하는 상황</u>**에서 사용된다.


## 해결방식

위상 정렬의 해결방식은 의외로 간단하다.   
1. **진입 차수 배열 선언**<br>
- 노드의 수만큼 진입 차수(degree)를 저장할 배열을 만든다.
2. **그래프 자료구조 생성**<br>
- 각 노드의 연결 정보를 담을 인접 리스트 또는 인접 행렬을 구성한다.
3. **진입 차수 계산**<br>
- 그래프를 순회하면서 각 노드의 진입 차수를 계산한다. **이때 선행 작업이 필요한 노드(도착 노드)의 인덱스에 +1을 해준다.**
4. **초기 큐 구성**<br>
- Queue를 선언하고, degree 값이 0인 노드들을 모두 넣는다. **진입 차수가 0이라는 것은 선행 조건이 없어 바로 실행 가능한 작업을 의미한다.**
5. **위상 정렬 실행**<br>
- Queue에서 노드를 하나씩 꺼내면서, 해당 노드와 연결된 다음 노드들의 진입 차수를 -1씩 감소시킨다. **이 과정을 Queue가 빌 때까지 반복한다.**


<br/>


## 코드구현

```python
import queue

print("일의 총 갯수 입력 : ")
cnt = int(input())
cnt += 1 # [0] 인덱스를 쓰지않을 것이기 때문에 +1
degree = [0 for _ in range(cnt)]
TopolList = [[] for _ in range(cnt)] 
# 인접 행렬형식으로 구현하려면 [[0 for _ in range(cnt)] for _ in range(cnt)]

print("일의 순서 입력 : ")
for i in range(1, cnt):
    WorkInput = input().split()
    start = int(WorkInput[0])
    end =  int(WorkInput[1])
    TopolList[start].append(end) # 인접 리스트 형식

for i in range(cnt):
    for j in range(len(TopolList[i])):
        degree[TopolList[i][j]] += 1 # 일 해야하는 카운트 증가
        
Q = queue.Queue()

for i in range(1, cnt):
    if degree[i] == 0:
        Q.put(i)

while not Q.empty():
    num = Q.get() # 큐에서 나오는 일들은 이제 일 할 수 있는 일 들을 뜻한다
    print(f"{num} ")
    for i in range(len(TopolList[num])):
        WorkNumber = TopolList[num][i]
        degree[WorkNumber] -= 1 # 다음 일 카운트 감소
        if degree[WorkNumber] == 0: 
            Q.put(WorkNumber) # 이제 일 할 수 있게된 일들 큐에 넣기

```

<br/>

> **가장 중요한 것은 degree 배열의 역할이다.**

포인트는 degree 배열에 지금 당장 실행가능한 노드는 **값이 0이라는 것**이고, 아닌 경우에는 **1이상의 값이 들어있다는 점**이다.   
그리고 Queue에서 현재 값이 0인 노드들을 하나씩 가져와 그 노드 **도착 노드의 값**을 degree배열에서 -1를 해주고,   
**이제 일 할 수 있게된 일들을 Queue에 넣어주며 반복하면 된다.**

<br/>


**선행 조건이 뚜렷한 일들을 표현할 때** 사용하면 매우 효율적으로 활용 가능할 것같다.   
또는 해야하는 일이 많지만 각 일들에 **선행 조건**이 있고, 그것이 매우 나눠져있어서 알아보기 힘든경우 한번에 정렬할 때 사용하면 매우 유용할 것 같다.


