---
title: "[QA][CSTS] CSTS 이론공부(4)"
layout: single
categories: QA
author_profile: true
sidebar_main: true
tag: [QA, CSTS]
published: true
---

CSTS 이론(4)
{: .notice--success}

> CSTS 자격증 공부를 하면서 Notion에 정리하였던 것을 블로그에도 정리   
> [[노션 링크]](https://lelernrn.notion.site/QA-262ca40c46968129acc6c6603a9ff02b?source=copy_link)



## 📝 위험 기반 테스트

테스트 대상과 범위를 결정할 때는 테스트 미수행에 따른 위험을 고려해야 한다.

즉, 테스트가 수행되지 않았다고 하더라도 그에 따른 위험 수준이 낮은 것들은 테스트 대상에서 제외할 수 있지만, 테스트 제외에 따른 위험 수준이 높은 것은 테스트 대상에 반드시 포함해야 한다.

> 이와 같이, **피처에 대한 위험 분석**을 바탕으로 **테스트에 대한 계획과 설계 그리고 실행** 등의 활동을 수행하는 것을 **위험 기반 테스트**라고 한다.
{: .notice--success}

## 📝 모델 기반 테스트

기존의 테스트는 모델을 이용하더라도 보통은 수작업으로 테스트 입력 및 출력을 결정하는 방식만을 제공하였다. 반면에, **모델 기반 테스트**는 **테스트 절차를 수행할 수 있는 정보가 자동으로 추출될 수 있을 정도로 정형화되고 상세한 모델을 바탕으로 한다.**

즉, 모델을 바탕으로 **테스트 계획을 수립**하고, **테스트 케이스**, **테스트 절차**, **테스트 입력 및 예상 결과 등을 결정**한다.

> 모델 기반 테스트 수행은 **테스트 계획**에서 **테스트 종료**까지 **대부분의 활동을 자동화할 수 있다는 이점**이 있다.
{: .notice--success}

> 모델 기반 테스트는 일단 모델이 구축된 후에는 자동화를 통해서 **효율적인 테스트를 수행할 수 있다는 이점이 있지만**, 모델 기반 테스트의 근간이 되는 모델, **즉, 정형적이고 상세한 테스트 모델을 구축하는 비용이 추가되는 단점이 있다.**
{: .notice--warning}

## 📝 모의 객체 생성 프레임워크
객체 지향 프로그램에서는 컴포넌트 테스트를 수행할 때 테스트 되는 메소드가 다른 클래스의 객체에 의존할 수 있다.   
하지만, 이런 경우에는 메소드를 고립화하여 테스트하는 것이 불가능 하다.   

따라서 **독립적인 컴포넌트 테스트를 위해서는 절차 지향적 프로그래밍에서 스텁과 같은 개념이 필요하다.**

> 모의(Mock) 객체는 스텁의 객체 지향 버전이라 할 수 있다.
{: .notice--warning}

## 📝 모의 객체

모의 객체는 다음과 같이 분류하기도 한다.

- **더미(Dummy) 객체** : 테스트할 때 객체만 필요하고 해당 객체의 기능까지는 필요하지 않은 경우에 사용된다. 더미 객체의 메소드가 호출되면 정상 동작은 수행하지 않고 예외를 던진다.
- **테스트 스텁(Stub)** : 더미 객체에 단순한 기능성을 작성하며 추가객체의 특정 상태를 가정해서 특정한 값을 리턴하거나 특정한 메세지를 출력하게 한다.
- **테스트 스파이(Spy)** : 주로 테스트 대상 클래스(CUT)와 협력하는 클래스로 가는 출력을 검증하는 데 사용하며 CUT가 실행되는 동안 특정 협력 클래스로의 호출(또는 호출의 결과)을 잡아내 실행이 끝난 후 정상 호출되었는지 검사.
- 가짜(Fake) 객체 : 실제 협력 클래스의 기능을 대체해야 할 경우에 사용하며 실제 협렵 클래스의 기능 중 전체나 일부를 훨씬 단순하게 구현한다.

## 📝 FIRST 원칙 (컴포넌트 테스트)
- **<u>Fast</u>** : 컴포넌트 테스트는 빠르게 수행되어야 한다.
    
    > *컴포넌트 테스트의 주요 목적 중 하나가 리그레션 테스트인데, 코드를 변경할 때마다 테스트가 오래 걸린다면 개발자는 테스트를 수행하지 않고자 하는 유혹에 빠질 수 있고, 코드에 새로운 기능이 추가될 수록 테스트 실행 시간은 증가될 것이다.*
    > 
    
- **<u>Isoloated</u>** : 컴포넌트 테스트가 다른 컴포넌트 테스트에 의존하지 않도록 해야한다.
    
    > *만약, 한 컴포넌트 테스트가 다른 컴포넌트 테스트의 수행 결과에 의존한다면 테스트 실행 순서에 따라 다른 결과가 나올 것이다. 즉, 전체 컴포넌트 테스트 집합을 실행한 결과와 개별적으로 컴포넌트 테스트를 실행한 결과가 달라서는 안된다.*
    > 
    
- **<u>Repeatable</u>** : 테스트를 몇 번 실행해도 동일한 결과가 나오도록 해야한다.
    
    > *만약 테스트를 실행할 때마다 다른 결과가 나온다면 더 이상 테스트 결과를 신뢰하지 않고 테스트를 수행하지 않게 될 것이다.*
    > 
    
- **<u>Self-Validating</u>** : 사람의 개입 없이 테스트가 통과되었는지 알 수 있도록 작성해야 한다.
    
    > *테스트 결과를 판단하기 위하여 사람이 개입하도록 작성하면 매우 많은 시간이 소요될 여지가 있고 많은 위험이 따른다. 또한, 테스트에 필요한 데이터 준비 작업이나 설정 파일 조작과 같은 작업도 자동화하여 사람이 개입할 필요가 없는 것이 좋다.*
    > 

- **<u>Timely</u>** : 컴포넌트 테스트는 제때 수행되어야 한다. 여기서 제때란 테스트 대상이 되는 코드가 작성되는 시점을 의미한다. TDD에서는 코드 작성 바로 전이다.

## 📝 통합 테스트의 목적
통합 테스트의 목적에 대해서는 두 가지 다른 관점이 있다.

- 자료에 따라 통합 테스트가 두 **컴포넌트 간 연결의 정확성에만 초점**을 두는 것.
- 연결된 두 컴포넌트의 **기능적인 측면에 초점**을 두는 것.

> 컴포넌트 간의 연결 자체에서 오작동이 발생할 가능성이 크다면, **첫 번째 방식의 통합 테스트를 먼저 수행하는 것이 효율적일 수 있다.** 
{: .notice--success}

> 하지만 컴포넌트 간의 통신에 문제가 있을 가능성이 작다면 **두 번째 방식처럼 바로 기능 위주의 통합 테스트를 수행하는 것이 더 효과적이다.**
{: .notice--warning}


## 📝 빅뱅 (통합 테스트)
전체 컴포넌트를 한 번에 통합하여 테스트하는 방법을 **빅뱅(Big-bang) 방식**이라고 부른다.


## 📝 점진적 방식
전체 컴포넌트를 한 번에 통합하는 빅뱅 방식 대신에 적은 수의 컴포넌트를 차례로 통합하는 점진적 방식을 적용하는 것이 효과적이다.

> 점진적 방식은 오작동의 원인이 되는 컴포넌트를 찾기 쉬운 반면 **테스트 드라이버 및 스텁을 여러 번 개발해야 한다**.
{: .notice--success}

> - **상향식 통합 테스트** : 호출 관계의 하위에 있는 컴포넌트들을 시작으로 해서 상위에 있는 **컴포넌트들을 통합하는 방식.**
- **하향식 통합  테스트**: 시스템을 구성하는 컴포넌트들의 계층 구조에서 가장 상위에 있는 **컴포넌트부터 시작하여 하위에 있는 컴포넌트들을 점진적으로 통합**하는 방식.
- **샌드위치 통합** : **상향식과 하향식 두 방법을 결합하여 시스템을 통합하는 방식.**
{: .notice--warning}

## 📝 APFD
테스트 케이스 **우선순위의 효과성을 평가하기 위한 척도**

## 📝 기능적합성 테스트의 부특성
- 완전성 : 모든 명시된 기능을 시스템이 제공하는 정도
- 적절성 : 사용자의 목적 달성에 소프트웨어가 도움을 주는 정도
- 정확성 : 정의된 정밀도에 따라 정확하게 결과를 제공하는 정도
- 가용성 : 신뢰성의 부특성

## 📝 **스파이크 테스트**
![image.png](https://github.com/user-attachments/assets/dea52845-0be0-40ef-95bf-990433f77505)

> **트래픽 부하를 극도로 증가 및 감소시키면서 소프트웨어 애플리케이션을 테스트하는 소프트웨어 테스트 유형**. 스파이크 테스트의 주요 목적은 **사용자가 갑자기 증가하거나 감소할 때 소프트웨어 애플리케이션의 동작을 평가하고 사용자 로드가 급증한 후 복구 시간을 결정**하는 것.*
{: .notice--warning}


## 📝 사용성을 평가하는 방법
- 인지적 워크쓰루
- FGI
- 휴리스틱 평가


## 📝 테스트 용이성 특성
<img width="2148" height="1202" alt="Image" src="https://github.com/user-attachments/assets/a5fb7106-f39e-456f-8072-cd95ef152224" />

> [유튜브 링크](https://www.youtube.com/watch?v=G6Hh8X-_0LQ)
{: .notice--success}

프로그램을 얼마나 손쉽게 테스트할 수 있는지를 나타내는 **테스트 용이성의 특징**

- **제어 용이성** - 프로그램의 실행을 제어하기 용이하도록 설계
- **안정성** - 테스트 동안에 소프트웨어에 대한 변경이 자주 발생하지 않도록 설계
- **분할 용이성** - 테스트할 대상 영역을 제어함으로써 문제가 발생된 곳을 고립시켜 독립적으로 모듈 시험
- **이해 용이성** - 소프트웨어 설계 정보가 잘 조직화되어 쉽게 접근 가능하도록 설계


## 📝 위험 기반 테스트 수행
위험 분석 결과는 효과적이고 효율적인 테스트를 수행하기 위한 계획을 수립할 때 사용된다. 

즉, 주어진 일정과 비용 내에서 중요한 테스트 대상을 결정하고, 더욱 집중적으로 테스트할 피처들을 선정하는 데 위험 분석 결과가 사용된다.

### <u>테스트에 대한 강도</u>

- **고강도 테스트** : 매우 높은 위험도를 가지는 피처들
- **균형적 테스트** : 고강도 테스트보다 낮은 위험도를 가지는 피처들
- **부가적 테스트** : 균형적 테스트로 분류되는 피처보다 낮은 위험도를 가지는 피처들


> 위험도(Risk)는 **장애가 발생할 가능성**과 **영향도**의 곱으로 계산한다.
(Boehm의 위험 노출 계산)   
**[ Probability * Impact ]**
{: .notice--success}


> **위험** - 프로젝트 목적 수행에 부정적인 영향을 미칠 수 있는 불확실한 이벤트나 조건.   
**위험 관리** - 잠재 위험이 문제로 발현되기 전에 **대응책을 생각해 내는 과정.**
{: .notice--danger}


## 📝 위험성의 요인
발생 가능성(B), 심각성(C), 긴급성(D)

### <u>위험도를 산정하기 위한 항목과 설명</u>   

- **발생가능성** : 해당 피처와 관련된 장애가 실행 시에 발생할 가능성
- **긴급성** : 관련 장애가 발생하였을 때 얼마나 시급한 수정이 필요한지의 정도
- **심각성** : 시스템의 기능 요소가 기대한 대로 동작하지 않을 때 미치는 영향의 정도

## 📝 리팩토링
기능을 변경하지 않고 코드의 내부 구조를 개선하는 작업