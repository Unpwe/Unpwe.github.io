---
title: "[QA][CSTS FL] CSTS 이론공부(3)"
layout: single
categories: CSTS
author_profile: true
sidebar_main: true
tag: [QA, CSTS]
published: true
---

CSTS FL 이론(3)
{: .notice--success}

> CSTS FL 자격증 공부를 하면서 정리한 개인적인 메모    
> [[노션 링크]](https://lelernrn.notion.site/QA-262ca40c46968129acc6c6603a9ff02b?source=copy_link)


## 📝 V 모델
4개의 레벨 테스트는 일반적인 소프트웨어의 개발 단계 즉 **요구 분석, 구조 설계(또는 아키텍처 설계), 상세 설계**와 밀접한 연관이 있다.   
좌측의 개발 단계와 우측의 테스트 수준이 알파벳 ‘V’ 형태를 이루므로 이를 **V 모델**이라고 부른다.




## 📝 주특성

- **기능 적합성**
    - 완전성, 정확성, 타당성
- **사용성**
    - 타당성 식별력, 학습성, 운영 용이성, 사용자 오류 보호, 사용자 인터페이스 미학, 접근성
- **성능 효율성**
    - 시간 행동, 자원 활용성, 수용성
- **호환성**
    - 공존성, 상호운영성
- **신뢰성**
    - 성숙성, 가용성, 장애 허용성, 회복 가능성
- **보안성**
    - 기밀성, 무결성, 부인방지, 책임성, 진본성
- **유지보수성**
    - 모듈성, 재사용성, 분석성, 변경 용이성, 테스트 용이성
- **이식성**
    - 적응성, 설치 용이성, 대치 용이성



## 📝 탐색적 테스트
경험 기반 테스팅의 종류로써 사전에 구체적으로 테스트 케이스를 설계하여 기록하고 이를 바탕으로 테스트를 수행하는 방식이 아니라, **테스트 대상에 대한 이해, 테스트 케이스의 설계, 테스트 실행을 병행하는 방식이다.**

### 탐색적 테스트의 단점

1. 초기에 시스템에 대한 정보 및 이해가 부족하므로 결함을 검출하기 위하여 명**확한 목표 없이 시스템의 이곳저곳을 탐색하는 데 과도한 시간을 사용할 위험이 있다.**
2. 여러 명 또는 여러 팀이 탐색적 테스트에 참여할 경우에 **동일한 기능을 중복해서 반복적으로 테스트할 위험이 있다.**
3. 테스트 범위를 명확하게 문서화하지 않고 테스트를 실시하므로 **테스트의 적합성 즉, 커버리지에 대한 판단을 할 수 없다.**



## 📝 재테스팅(확인 테스팅)
테스팅을 통해서 검출된 결함이 올바르게 해결되었는지 여부에 앞서 결함을 검출한 테스트 절차(테스트 케이스)를 활용해서 다시 테스팅을 수행해야한다.

**재테스팅(확인 테스팅)은 검출된 결함의 해결 여부가 검증될 때까지 반복적으로 수행될 수 있다.**

> 예를 들어, 1차 재테스팅에서 결함이 올바르게 해결되지 않았다는 것이 확인되면 개발자는 다시 **해당 결함을 해결하기 위하여 디버깅과 소스 코드 수정을 수행할 것**이다. 이 수정된 소드 코드를 대상으로 **2차 재테스팅을 수행하게 된다.**
{: .notice--danger}

> 재테스팅은 **컴포넌트 테스트, 통합 테스트, 시스템 테스트 등** **여러 레벨**에서, 그리고 **성능 테스트, 신뢰성 테스트 등** **여러 유형**에서 수행될 수 있다.
{: .notice--success}


> **낮은 심각도의 결함에 대해서는 컴포넌트 테스트와 통합 테스트에서는 생략하고 시스템 테스트에서 재테스팅을 수행할 수 있다.**
{: .notice--warning}



## 📝 리그레션 테스트
리그레션 테스트는 변경 후에 수행되는 테스트로, 소프트웨어에 가해진 변경이 의도하지 않게 결함을 만들지는 않았는지, **시스템이 기존의 요구사항을 충족하는지 검증 하기 위하여 수행**된다.

보통 유지보수 단계에서 리그레션 테스트를 수행하는 방법은 **개발 단계에서 사용한 테스트 케이스를 이요하는 것이다.**

> 개발 단계에서 사용한 테스트 케이스를 수정된 프로그램에 실행하여, **그 결과가 수정되기 전 프로그램에서 실행한 결과와 차이가 있는지 비교해본다. 만약 다르다면 이 변화가 의도한 것인지 확인하고 의도한 결과가 아니라면 프로그램에 결함이 있다고 판단할 수 있다.**
{: .notice--success}



리그레션 테스팅을 수행할 테스트 레벨 결정은 **소프트웨어에 가해진 변경의 유형**과 **그 영향에 대한 추정**을 바탕으로 한다.   
예를 들어, 컴포넌트 내부의 알고리즘 변경으로 그 영향이 컴포넌트 내부로만 한정되고 **컴포넌트 간의 연결에 대한 영향이 적다면** 컴포넌트 테스트와 시스템 테스트에서 리그레션 테스팅을 수행하고 **통합 테스트에서는 생략할 수 있다.**   

> 또한, **변경의 유형이 기능에 한정되고 이로 인한 성능에 대한 영향이 미약**하다면 **성능 테스트의 리그레션 테스팅은 생략될 수 있다.**
{: .notice--warning}



## 📝 소프트웨어 생명 주기
소프트웨어 생명 주기는 **소프트웨어 개발 체계의 추상적 표현**이며 **순차적 또는 병렬적인 일련의 단계로 구성된다.**

> 예를 들어, **요구사항을 수집하고 문제를 이해,분석하는 단계부터 시작하여 설계 단계 및 시스템을 구성하는 모듈을 구현하는 단계를 거친다.**
{: .notice--warning} 

- 테스트는 이러한 소프트웨어 생명 주기 모델의 특성을 고려하여 수행되어야 한다.

    > **순차적 생명 주기 모델**의 경우, 테스트는 구현이 완료된 시점에 1회만 수행되지만, **진화형 모델**과 **애자일 모델**과 같이 반복적이고 점진적인 모델에서는 테스트도 반복적, 점진적으로 수행된다.   
    {: .notice--success}

    - **순차적 생명 주기 모델** : 폭포수 모델, V-모델
    - **진화적 개발 모델** : 이터레이션, 점진적인 방식
    - **애자일 개발 방법론** : 테스트 주도 개발(Test-Driven Development, TDD)
        - TDD와 더불어 애자일 개발에서 중요한 실천 규칙인 **지속적 통합(CI, Continuous Integration)**이 있다.         
            > 말 그대로 **지속적 통합**은 통합이 어느 한 시점에 이루어지는 것이 아니라 **계속해서 통합**을 수행하는 것  
    {: .notice--danger}
    

### 순차적 개발 모델

> **요구사항이 개발 초기에 완전하게 정의되어 있을 때는 적합**하지만, **불확실한 요구사항 또는 요구사항 변경이 빈번하게 발생하는 경우에는 적합하지 않다.**
> 

> **프로세스와 문서 위주의 방법론**
{: .notice--success}

### 진화적 개발 모델

> **시스템의 구성요소 중 핵심 부분을 개발한 후**,  각 구성요소와 추가 요구사항을 여러 이터레이션을 통해 개선 발전시켜 최종 완성품을 개발한다.
> 

**요구사항이 불명확할 때 사용하기 적합한 개발 모델**로 시스템 구성 요소를 조금씩 개발 반복적으로 수행하여 프로젝트를 진행하는 방식으로 **대규모 프로젝트에 적합하다.**
> - 매 단계 테스트가 수행되므로 많은 문제점을 해결할 기회를 가질 수 있다.
{: .notice--warning}

### 애자일 개발 모델


**애자일 선언**
> - *사람 및 상호 의사 교환이 프로세스나 도구보다 우선한다.*
- *동작하는 소프트웨어가 포괄적인 문서보다 우선한다.*
- ***고객과의 협력이 계약 협상보다 우선한다.***
- ***변화에 반응하는 것이 계획을 따르는 것보다 우선한다.***
{: .notice--danger}

### IDD (Interative and Incremental Development)

> *반복적이면서 점진적인 개발 접근 방식*
> 

### TDD (Test-Driven Development)

> **<u>테스트 주도 개발</u>**   
> **프로그램에 대한 테스트 케이스를 먼저 작성하고, 이 테스트 케이스로 테스트 되는 실제 프로그램의 코드를 나중에 작성하는 방식**

> 기본적으로 TDD는 단위 테스트를 위한 것이다.
**객체 지향 프로그램에서 단위는 보통 하나의 클래스를 의미한다.**
{: .notice--success}