---
title: "[프로그래머스][C++] [LV.3] 연속 펄스 부분 수열의 합"
layout: single
categories: Cpp
author_profile: true
sidebar_main: true
tag: [Cpp, CodingTest]
toc: true
published: true
---





CodingTest
{: .notice--warning}



## 문제

![image](https://github.com/PREADIM/PREADIM.github.io/assets/69719507/41765b62-f11a-4113-bcf6-6f8e9ed01f0e)

이 문제는 주어진 수열에 펄스 수열을 곱하여서 나온 값 수열에서 연속 합이 가장 큰 값을 구하는 문제이다.    
여기서 말하는 펄스 수열이란 {-1, 1, -1, ...} 이나 {1, -1, 1,...} 처럼 1과 -1이 번갈아 가면서 나오는 수열을 말한다.


<br>



## 해결방식


처음 봤을때 펄스 수열에 따라 수열 자체가 달라지므로 배열 두개를 만들어서 펄스 수열을 곱한 값을 먼저 구한뒤 해당 배열의 누적합으로 문제를 풀려고 하였다.    

하지만 길이기 50만에다가, 반환 값이 long long 형을 사용 할 정도로 누적합이 커질 수가 있어서 구현을 하는 와중에도 의심스러웠다.    

그러다가 우연히 하나의 배열을 통해 누적합으로 풀어내는 방법을 발견하였고 그 방법으로 풀어 보았다.


<br>


## 코드



```cpp
#include <iostream>
#include <vector>

using namespace std;

long long solution(vector<int> sequence) {
    
    vector<long long> pulse(sequence.size());
    long long MaxNum, MinNum;
    MaxNum = MinNum = pulse[0] = sequence[0];

    
    for(int i = 1; i < sequence.size(); i++)
    {
        // 누적 합을 구해서 큰값에서 작은 값을 빼면 폭이 나온다.
        // 펄스 수열의 누적합은 결국 서로 부호만 다르기 때문에, 최대값 최소값이 서로 반대이다.
        pulse[i] = pulse[i - 1] + (sequence[i] * ((i % 2) ? -1 : 1));
        if(MaxNum < pulse[i])
            MaxNum = pulse[i];
        else if(MinNum > pulse[i])
            MinNum = pulse[i];
    }

    /* 위에서 누적합을 진행한 배열은 {1, -1, 1,...} 형태로 진행했기 때문에 {-1, 1, -1,...}로 진행하는 경우의 최대값과 최소값도 계산 해주어야 한다.
    최소값이 양수인 경우, 최대값 그 자체가 더 클수도 있고, 최소값은 즉 반대 펄스 부분 수열의 최대값이므로 절댓값으로 비교해본다.*/
    return max(max(MaxNum - MinNum, MaxNum), abs(MinNum));
}
```

> 도움을 받은 블로그

https://velog.io/@adantenr/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4Lv.-3-%EC%97%B0%EC%86%8D-%ED%8E%84%EC%8A%A4-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9



> **펄스 수열은 눈속임이다.**

펄스 수열은 말그대로 1과 -1을 반복하는 수열이다.    
연속 부분 수열에 펄스 수열을 곱하고 부분 수열의 처음부터 끝까지의 누적합을 구한다.
그 후 최소값과 최대 값을 확인하면 {1, -1, 1,...}의 펄스 수열을 곱한 것과, {-1, 1, -1,...}의 펄스 수열을 곱한 값이 정확히 반대로 되어있다.

즉 -1부터 시작한 펄스 수열을 곱한 값의 누적 최대값은 1부터 시작한 펄스 수열을 곱한 값의 누적 최소값이다.    
어떤 그래프의 폭이라고 하는 말은 들었지만, 솔직히 말해서 정확한 원리는 모르겠다..

하지만 중요한 것은 하나의 펄스 수열만 이용해도 나온 누적 값의 최대값 - 최소값을 하면 해당 부분 수열의 가장 큰 합을 구할 수 있다는 것이다.


> **원본 : [100, 200, 300, 400, 500]**   
> * {-1, 1, -1,...} 펄스 수열 적용 : [-100, 200, -300, 400, -500] 
>> -> 누적 합 : [-100, 100, -200, 200, -300]    
>> -> Max : 200 / Min : -300   
>> -> Max - Min = 500
> * {1, -1, 1,...} 펄스 수열 적용 : [100, -200, 300, -400, 500] 
>> -> 누적 합 : [100, -100, 200, -200, 300]    
>> -> Max : 300 / Min : -200   
>> -> Max - Min = 500


<br>

> **예외처리를 해주어야한다.**

최대값 - 최소값을 하면 답이 나오기는 하지만 예외가 있다.   
바로 최소값이 음수인 경우이다. 예시를 보자.

> **원본 : [1, -2, 3, -4, 5]**   
> * {1, -1, 1,...} 펄스 수열 적용 : [1, 2, 3, 4, 5] 
>> -> 누적 합 : [1, 3, 6, 10, 15]    
>> -> Max : 15 / Min : 1   
>> -> Max - Min = 14(?)

이렇게 모든 수가 양수가 나와서 최소값도 양수인 경우는 최대값 그 자체가 가장 큰 합이기 때문이다.   
또한 다른 예외도 있다.

> **원본 : [-1, 2, -3, 4, -5]**   
> * {1, -1, 1,...} 펄스 수열 적용 : [-1, -2, -3, -4, -5] 
>> -> 누적 합 : [-1, -3, -6, -10, -15]    
>> -> Max : -1 / Min : -15   
>> -> Max - Min = 14(?)

이번엔 모든 수가 음수인 경우 최대값이 음수이기 때문에 최솟값이 양수인 경우과 같아진다.    
이 예외는 현재 곱한 펄스 수열이 아닌 다른 펄스 수열로 곱한 경우 모든수가 양수인 경우와 같아진다.   
때문에 위에서 서술한 펄스 수열의 누적값의 최대값과 최소값은 서로 반대인 것을 이용하여 Min의 절댓값(다른 펄스 수열을 이용했을 때의 Max 값) 까지 std::max 함수로 비교를 해주어야 한다.

때문에 하나의 펄스 수열을 이용하여 부분 수열의 값을 전부 곱하며 누적값을 구했다면 최종적으로 최대값과 최소값을 std::max 함수를 통하여 예외처리를 해주었다.

> return max(max(MaxNum - MinNum, MaxNum), abs(MinNum));


<br>


## 해결

![image](https://github.com/PREADIM/PREADIM.github.io/assets/69719507/785912cf-f9b3-4fb4-b0b6-08f1de2e971e)




***

출처: 프로그래머스 코딩 테스트 연습    
https://school.programmers.co.kr/learn/challenges