---
title: "[백준][C++] [10989] 수 정렬하기 3"
layout: single
categories: Cpp
author_profile: true
sidebar_main: true
tag: Cpp, CodingTest
toc: true
published: true
---



CodingTest
{: .notice--warning}



## 문제

![image](https://github.com/PREADIM/PREADIM.github.io/assets/69719507/748766bd-c3d9-40b5-9de3-5d3214f2ab11)

이 문제는 랜덤으로 주어지는 수를 정렬 하는 문제이다. 처음엔 그냥 "기수 정렬로 해결하면 되겠네" 라고 쉽게 생각했지만 조건이 매우 빡빡하다. (정답률이 23%..)


<br>



## 해결방식


일단 수의 개수부터 10,000,000개 에다가 메모리 제한이 8MB이다. 이 소리는 short형으로 배열을 저장하여도 메모리 제한에 걸리게 된다. 따라서 이문제는 **'저장하지 않고 정렬 하는 방법'** 을 떠올려야 했고, 이 방법을 위해 **'카운팅 정렬'** 을 이용하였다.


<br>


## 코드



```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();

	int arr[10001] = { 0 };

	int N;
	cin >> N;

    // 수가 입력되면 해당 자리에 카운팅 증가
	for (int i = 0; i < N; i++)
	{
		unsigned short num;
		cin >> num;
		arr[num]++;
	}

    // 배열에 카운팅 되어있는 만큼 출력
	for (int i = 0; i < 10001; i++)
	{
		if (arr[i] > 0)
		{
			for(int j = 0; j < arr[i]; j++)
				cout << i << '\n';
		}	
	}		
}
```

<br>

> **카운팅 정렬에서 일부분만 사용한 방식**

카운팅 정렬 방식은 중복되는 수가 많고, 범위가 작을 수록 효율적인 정렬 방식이다.   
보통 카운팅 정렬 방식은 이렇다.
>  1. 배열의 요소의 갯수를 나타낼 배열 A를 선언하고 전부 0으로 초기화 해준다.
>  2. 정렬 해야할 배열을 순차적으로 돌면서 접근하여 배열 요소를 A 배열의 인덱스로 사용하여 값을 증가 시킨다.
>  3. 전부 카운팅을 했으면 A 배열에 저장된 증가된 값을 이용하여 해당 원소가 몇 번째에 위치 해야하는지 앞에서부터 누적합을 구해서 새롭게 저장 한다.
>  4. 정렬 해야할 배열을 뒤에서 부터 순차적으로 돌면서 해당 요소를 인덱스로 배열 A에 접근하고 배열 A에 저장되어있는 누적합을 이용해 새로운 배열에 저장한다. 또한 해당 누적합을 -1 해준다.

하지만 이 문제에서는 누적합을 구하는 과정도 없고, 정렬할 배열을 탐색하는 과정도 없다.


<br>

> **이 문제에서는 애초에 값을 저장 할 수가 없다.**

카운팅 정렬은 일단 배열의 요소를 알고 있어야 누적합을 이용이 가능한데, 이 문제는 저장하는 즉시 메모리 제한에 걸리기 때문에 '입력 받는 즉시 정렬 되는 방식'으로 해결해야 했다.   

때문에, 값을 입력 받으면 그 값으로 미리 선언한 배열의 인덱스로 이동하여 값을 카운팅 하였고, 전부 카운팅 하였으면 앞에서부터 차례대로 카운팅 되어 있는 만큼 출력하는 방식으로 해결하였다.


<br>


## 해결

![image](https://github.com/PREADIM/PREADIM.github.io/assets/69719507/09882c4b-e826-49b0-bded-9459f62130a2)



코드만 보면 매우 간단해보이지만, 의외로 한번도 해본적 없는 방식이라 어려웠다.   
왜 정답률이 23%인지 알겠다..


***